#!/usr/bin/env python3
"""
Test script to validate planet positions generated by the astrology app
against known test data.

Test Data: DOB 22/08/1996 - 12:23 PM, Coimbatore, IN
Lat: 11.0055, Long: 76.9661, Time Zone Offset: 5.5
"""

import requests
import json
from datetime import datetime
import sys
import os

# Test configuration
TEST_DATA = {
    'datetime': '1996-08-22T12:23:00',
    'place': 'Coimbatore, India',
    'lat': 11.0055,
    'lon': 76.9661,
    'tz_offset': 5.5,
    'ayanamsa': 'lahiri',
    'house_system': 'equal',
    'node_type': 'mean'
}

# Expected planet positions from the test data
EXPECTED_POSITIONS = {
    'Sun': {
        'degree': 125.633,  # 125° 38'
        'rasi': 'Leo',      # Simha
        'nakshatra': 'Magha'
    },
    'Moon': {
        'degree': 217.35,   # 217° 21'
        'rasi': 'Scorpio',  # Vrischika
        'nakshatra': 'Anuradha'
    },
    'Mercury': {
        'degree': 152.95,   # 152° 57'
        'rasi': 'Virgo',    # Kanya
        'nakshatra': 'Uttara Phalguni'
    },
    'Venus': {
        'degree': 79.9,     # 79° 54'
        'rasi': 'Gemini',   # Mithuna
        'nakshatra': 'Ardra'
    },
    'Mars': {
        'degree': 84.367,   # 84° 22'
        'rasi': 'Gemini',   # Mithuna
        'nakshatra': 'Punarvasu'
    },
    'Jupiter': {
        'degree': 254.233,  # 254° 14'
        'rasi': 'Sagittarius', # Dhanu
        'nakshatra': 'Purva Ashadha'
    },
    'Saturn': {
        'degree': 342.617,  # 342° 37'
        'rasi': 'Pisces',   # Meena
        'nakshatra': 'Uttara Bhadrapada'
    },
    'Rahu': {
        'degree': 166.217,  # 166° 13'
        'rasi': 'Virgo',    # Kanya
        'nakshatra': 'Hasta'
    },
    'Ketu': {
        'degree': 346.217,  # 346° 13'
        'rasi': 'Pisces',   # Meena
        'nakshatra': 'Uttara Bhadrapada'
    }
}

# Expected Ascendant
EXPECTED_ASCENDANT = {
    'degree': 215.417,  # 215° 25'
    'rasi': 'Scorpio',  # Vrischika
    'nakshatra': 'Anuradha'
}

# Sign name mappings
SIGN_MAPPINGS = {
    'Aries': 'Aries',
    'Taurus': 'Taurus', 
    'Gemini': 'Gemini',
    'Cancer': 'Cancer',
    'Leo': 'Leo',
    'Virgo': 'Virgo',
    'Libra': 'Libra',
    'Scorpio': 'Scorpio',
    'Sagittarius': 'Sagittarius',
    'Capricorn': 'Capricorn',
    'Aquarius': 'Aquarius',
    'Pisces': 'Pisces'
}

def convert_degrees_minutes_to_decimal(degree_str):
    """Convert degree string like '125° 38'' to decimal degrees"""
    try:
        if '°' in degree_str and "'" in degree_str:
            parts = degree_str.replace("'", "").split('°')
            degrees = float(parts[0].strip())
            minutes = float(parts[1].strip())
            return degrees + (minutes / 60.0)
        else:
            return float(degree_str)
    except:
        return 0.0

def test_astrology_api():
    """Test the astrology API with the given test data"""
    
    print("=" * 60)
    print("ASTROLOGY APP PLANET POSITION VALIDATION TEST")
    print("=" * 60)
    print(f"Test Date: {TEST_DATA['datetime']}")
    print(f"Location: {TEST_DATA['place']}")
    print(f"Coordinates: {TEST_DATA['lat']}°N, {TEST_DATA['lon']}°E")
    print(f"Timezone: UTC+{TEST_DATA['tz_offset']}")
    print("=" * 60)
    
    # Test if the Flask app is running
    base_url = 'http://localhost:5000'
    
    try:
        # Test connection
        response = requests.get(f"{base_url}/", timeout=5)
        print("✓ Flask app is running")
    except requests.exceptions.RequestException as e:
        print(f"✗ Flask app is not running or not accessible: {e}")
        print("Please start the Flask app with: python app.py")
        return False
    
    # Make API request
    try:
        response = requests.post(
            f"{base_url}/api/chart",
            json=TEST_DATA,
            timeout=30
        )
        
        if response.status_code != 200:
            print(f"✗ API request failed with status code: {response.status_code}")
            print(f"Response: {response.text}")
            return False
            
        data = response.json()
        
        if not data.get('ok'):
            print(f"✗ API returned error: {data.get('error', 'Unknown error')}")
            return False
            
        chart_data = data['data']
        print("✓ Successfully received chart data from API")
        
    except requests.exceptions.RequestException as e:
        print(f"✗ API request failed: {e}")
        return False
    except json.JSONDecodeError as e:
        print(f"✗ Failed to parse JSON response: {e}")
        return False
    
    # Validate results
    return validate_positions(chart_data)

def validate_positions(chart_data):
    """Validate the planet positions against expected data"""
    
    print("\n" + "=" * 60)
    print("PLANET POSITION VALIDATION")
    print("=" * 60)
    
    total_tests = 0
    passed_tests = 0
    tolerance_degree = 1.0  # Allow 1 degree tolerance for positions
    
    # Validate Ascendant
    print("\n🎯 ASCENDANT VALIDATION:")
    if 'ascendant' in chart_data:
        actual_asc = chart_data['ascendant']
        expected_asc = EXPECTED_ASCENDANT['degree']
        
        degree_diff = abs(actual_asc - expected_asc)
        total_tests += 1
        
        if degree_diff <= tolerance_degree:
            print(f"✓ Ascendant: {actual_asc:.2f}° (Expected: {expected_asc:.2f}°) - PASS")
            passed_tests += 1
        else:
            print(f"✗ Ascendant: {actual_asc:.2f}° (Expected: {expected_asc:.2f}°) - FAIL (Diff: {degree_diff:.2f}°)")
    else:
        print("✗ Ascendant data not found in response")
        total_tests += 1
    
    # Validate Planets
    print("\n🪐 PLANET POSITION VALIDATION:")
    
    if 'planets' not in chart_data:
        print("✗ No planet data found in response")
        return False
    
    planets_data = chart_data['planets']
    
    for planet_name, expected in EXPECTED_POSITIONS.items():
        total_tests += 1
        
        if planet_name not in planets_data:
            print(f"✗ {planet_name}: Not found in response - FAIL")
            continue
        
        actual = planets_data[planet_name]
        
        # Check degree position
        if 'longitude' in actual:
            actual_degree = actual['longitude']
        elif 'degree' in actual:
            actual_degree = actual['degree']
        else:
            print(f"✗ {planet_name}: No position data found - FAIL")
            continue
        
        expected_degree = expected['degree']
        degree_diff = abs(actual_degree - expected_degree)
        
        # Check sign
        actual_sign = actual.get('sign', 'Unknown')
        expected_sign = expected['rasi']
        sign_match = actual_sign == expected_sign
        
        # Check nakshatra if available
        nakshatra_match = True
        if 'nakshatra' in actual and 'name' in actual['nakshatra']:
            actual_nakshatra = actual['nakshatra']['name']
            expected_nakshatra = expected['nakshatra']
            nakshatra_match = actual_nakshatra == expected_nakshatra
        
        # Determine if test passes
        position_pass = degree_diff <= tolerance_degree
        
        if position_pass and sign_match:
            status = "✓ PASS"
            passed_tests += 1
        else:
            status = "✗ FAIL"
        
        # Print detailed results
        print(f"\n{planet_name}:")
        print(f"  Position: {actual_degree:.2f}° (Expected: {expected_degree:.2f}°) - {'✓' if position_pass else '✗'} (Diff: {degree_diff:.2f}°)")
        print(f"  Sign: {actual_sign} (Expected: {expected_sign}) - {'✓' if sign_match else '✗'}")
        
        if 'nakshatra' in actual and 'name' in actual['nakshatra']:
            print(f"  Nakshatra: {actual['nakshatra']['name']} (Expected: {expected['nakshatra']}) - {'✓' if nakshatra_match else '✗'}")
        
        print(f"  Overall: {status}")
    
    # Print summary
    print("\n" + "=" * 60)
    print("TEST SUMMARY")
    print("=" * 60)
    print(f"Total Tests: {total_tests}")
    print(f"Passed: {passed_tests}")
    print(f"Failed: {total_tests - passed_tests}")
    print(f"Success Rate: {(passed_tests/total_tests*100):.1f}%")
    
    if passed_tests == total_tests:
        print("\n🎉 ALL TESTS PASSED! Planet positions are accurate.")
        return True
    else:
        print(f"\n⚠️  {total_tests - passed_tests} tests failed. Please check calculations.")
        return False

def save_debug_data(chart_data):
    """Save the API response for debugging"""
    debug_file = 'test_debug_output.json'
    try:
        with open(debug_file, 'w') as f:
            json.dump(chart_data, f, indent=2)
        print(f"\n📁 Debug data saved to: {debug_file}")
    except Exception as e:
        print(f"Failed to save debug data: {e}")

if __name__ == "__main__":
    print("Starting Astrology App Planet Position Test...")
    
    # Check if Flask app is running
    success = test_astrology_api()
    
    if not success:
        print("\n" + "=" * 60)
        print("TROUBLESHOOTING GUIDE")
        print("=" * 60)
        print("1. Make sure the Flask app is running:")
        print("   cd /path/to/astrology")
        print("   python app.py")
        print()
        print("2. Ensure the app is accessible at http://localhost:5000")
        print()
        print("3. Check that all required dependencies are installed:")
        print("   pip install -r requirements.txt")
        print()
        print("4. Verify the Swiss Ephemeris files are present")
        
        sys.exit(1)
    else:
        print("\n🎉 Test completed successfully!")
        sys.exit(0)